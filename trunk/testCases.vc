void test_qsortSwap()
{
	nSortArray[0] = 10;
	nSortArray[1] = 15;
	
	qsortSwap(0, 1);
	
	assertTrue(nSortArray[0] == 15);
	assertTrue(nSortArray[1] == 10);
}

void test_implode()
{
	nSortArray[0] = 10;
	nSortArray[1] = 15;
	nSortArray[2] = -1;

	assertTrue(strcmp(implode(), "10 15 ") == 0);
}

void test_qsort()
{
	string sData = "2 1 3 4 ";

	assertTrue(strcmp(qsort(sData, 0, TokenCount(sData, " ")-1), "1 2 3 4 ") == 0);
}

void test_qsortByOther()
{
	string sData = "2 1 3 5 ";
	string sKeys = "4 3 2 1 ";

	assertTrue(strcmp(qsortbyother(sData, sKeys, 0, TokenCount(sData, " ")-1), "5 3 1 2 ") == 0);
}

void test_NodeWithShortestDistance()
{
	int result;
	
	//setup some distances
	EmptyQueue();
	
	queue[0] = 0;
	queue[1] = 1;
	queue[2] = 2;
	
	nDistances[0] = 10;
	nDistances[1] = 5;
	nDistances[2] = 15;
	
	result = NodeWithShortestDistance();

	assertTrue(result == 1);
	
	//clean up after your self
	nDistances[0] = 0;
	nDistances[1] = 0;
	nDistances[2] = 0;
	
	EmptyQueue();
}


/*returns 1 if the hit is on the left
returns 2 if the hit is on the right
returns 3 if the hit is to the top
returns 4 if the hit is to the bottom
*/

void test_XYCollision()
{
	//objects outside each other
	assertFalse(CheckCollisionXY(1, 1, 1, 1, 5, 5, 10, 10));
	
	//object one colides on left side of object two
	assertTrue(CheckCollisionXY(13, 8, 5, 2, 5, 5, 10, 10) == 1);

	//object one colides on right side of object two
	assertTrue(CheckCollisionXY(3, 8, 5, 2, 5, 5, 10, 10) == 2);

	//object one colides on top side of object two
	assertTrue(CheckCollisionXY(6, 14, 2, 4, 5, 5, 10, 10) == 3);
	
	//object one colides on bottom side of object two
	assertTrue(CheckCollisionXY(7, 3, 2, 7, 5, 5, 10, 10) == 4);
}

void test_FoV()
{
	assertFalse(FoV(5, 5, 5, 5, 45, 90));
	
	assertTrue(FoV(5, 5, 5, 5, 45, 270));
	
	assertTrue(FoV(15, 5, 5, 5, 45, 90));
}